import { CreationAttributes, DataTypes, Op, Transaction } from 'sequelize'
import { BAD_REQUEST, MEMBER_ATTRIBUTE_ADDRESS_TYPES, SYSTEM_ERROR, memberAttributeArchTypeFromType } from '../config'
import type { MemberAttribute } from '../models/memberAttribute.model'
import type { AttributeChoice } from '../models/attributeChoice.model'
import { AppError, EncUtils, writeLog } from '../utilities'
import { db } from '../models'

const memberAttributeDbColType = Object.freeze({
	textarea: DataTypes.TEXT,
	text: DataTypes.STRING,
	number_integer: DataTypes.INTEGER,
	number_float: DataTypes.FLOAT,
	date: DataTypes.DATEONLY,
	time: DataTypes.TIME,
	datetime: DataTypes.DATE,
	boolean: DataTypes.BOOLEAN,
	select: DataTypes.STRING,
	radio: DataTypes.STRING,
	checkbox: DataTypes.STRING,
	file: DataTypes.STRING,
	image: DataTypes.STRING,
	video: DataTypes.STRING,
	audio: DataTypes.STRING,
	color: DataTypes.STRING,
	url: DataTypes.STRING,
	email: DataTypes.STRING,
	telephone: DataTypes.STRING,
	address_postal: DataTypes.STRING,
	address_prefecture: DataTypes.STRING,
	address_city: DataTypes.STRING,
	address_address: DataTypes.STRING,
	address_building: DataTypes.STRING,
	firstName: DataTypes.STRING,
	lastName: DataTypes.STRING,
	firstNameKana: DataTypes.STRING,
	lastNameKana: DataTypes.STRING,
	fullName: DataTypes.STRING,
	fullNameKana: DataTypes.STRING
})
// Generate a random section label
export function generateSectionLabel(): string {
	return EncUtils.generateToken().toString()
}

export function typeIsValidMemberAttributeType(type: string): type is memberAttributeType {
	return !!Object.getOwnPropertyDescriptor(memberAttributeDbColType, type)
}

export function generateAddressAttributes(args: {
	required: MemberAttribute['required']
	label: MemberAttribute['label']
	isMemberDisplayed: MemberAttribute['isMemberDisplayed']
	isAdminDisplayed: MemberAttribute['isAdminDisplayed']
	type: 'address'
}) {
	const section = generateSectionLabel()
	return MEMBER_ATTRIBUTE_ADDRESS_TYPES.map((type) => ({
		required: args.required,
		label: args.label,
		type: type,
		section: section,
		isMemberDisplayed: args.isMemberDisplayed,
		isAdminDisplayed: args.isAdminDisplayed
	}))
}

// Safely parse incoming data by type
export const safeParseCustomMemberAttributeData = ({
	item,
	data,
	files
}: {
	item: MemberAttribute
	data: unknown
	files?: { [fieldname: string]: Express.Multer.File[] } | Express.Multer.File[] | undefined
}): string | Date | number | null => {
	if (!data) return null
	if (!typeIsValidMemberAttributeType(item.type)) return null

	const dbColType = memberAttributeDbColType[item.type]
	if (dbColType == DataTypes.STRING || dbColType == DataTypes.TEXT) {
		if (item.type === 'image') {
			let file: Express.Multer.File | undefined
			const fileName = data
			if (Array.isArray(files) && fileName) {
				file = files.find((item) => item?.originalname === fileName)
			}
			// Return randomly assigned filename generated by multer
			return file?.filename || null
		} else {
			return (data as string)?.trim()
		}
	} else if (dbColType == DataTypes.INTEGER) {
		const valueNumber = parseInt(data as string)

		if (isNaN(valueNumber)) {
			throw new AppError(BAD_REQUEST, 'validate number', false)
		}
		return valueNumber
	} else if (dbColType == DataTypes.FLOAT) {
		const valueFloat = parseFloat(data as string)

		if (isNaN(valueFloat)) {
			throw new AppError(BAD_REQUEST, 'validate float', false)
		}
		return valueFloat
	} else if (dbColType == DataTypes.DATEONLY || dbColType == DataTypes.DATE) {
		const newDate = new Date(data as string)
		const isValid = !isNaN(newDate.getTime())
		if (!isValid) {
			throw new AppError(BAD_REQUEST, 'validate datepicker', false)
		}
		return newDate
	} else if (dbColType == DataTypes.TIME) {
		// Return 'HH:mm:ss' format where the seconds are optional
		const timeRegex = /^([01]\d|2[0-3]):([0-5]\d)(?::([0-5]\d))?$/
		// Test if the timeString matches the pattern
		const result = timeRegex.test(data as string)
		if (!result) {
			throw new AppError(BAD_REQUEST, 'validate time', false)
		}
		return data as string
	} else if (dbColType == DataTypes.BOOLEAN) {
		const boolValue = (data as string).toLowerCase().trim()
		if (!/^(true|false|0|1)$/.test(boolValue)) {
			throw new AppError(BAD_REQUEST, 'validate boolean', false)
		}
		// Convert boolean to number
		return Number(boolValue == 'true' || boolValue == '1')
	} else if (item.type === 'checkbox') {
		const selectId = (data as string)?.split(',')

		if (item.required) {
			const selectCheckbox: any = item.attributeChoices?.filter((item) =>
				selectId.includes(`${item.attributeChoiceId}`)
			)

			if (!selectCheckbox?.length) {
				throw new AppError(BAD_REQUEST, 'validate checkbox', false)
			}

			const attributeChoiceContents = selectCheckbox.map((i: any) => i.contents)

			return attributeChoiceContents.join(', ')
		} else {
			let attributeChoiceContents: any
			if (selectId) {
				const selectCheckbox = item.attributeChoices?.filter((item) =>
					selectId.includes(`${item.attributeChoiceId}`)
				)
				attributeChoiceContents = selectCheckbox?.map((i: any) => i.contents)
			}

			return attributeChoiceContents?.length ? attributeChoiceContents?.join(', ') : null
		}
	} else if (item.type === 'radio') {
		const attributeChoiceId = data

		if (item.required) {
			const selectRadio: any = item.attributeChoices?.find(
				(item) => item.attributeChoiceId === Number(attributeChoiceId)
			)

			if (!selectRadio) {
				throw new AppError(BAD_REQUEST, 'validate radio', false)
			}

			return selectRadio?.contents
		} else {
			let selectRadio: any = {}
			if (attributeChoiceId) {
				selectRadio = item.attributeChoices?.find(
					(item) => item.attributeChoiceId === Number(attributeChoiceId)
				)
			}
			return selectRadio?.contents
		}
	} else {
		throw new AppError(SYSTEM_ERROR, 'data error', false)
	}
}
export const getMaxShowOrder = async (transaction?: Transaction) => {
	const maxShowOrder = (await db.MemberAttribute.max('showOrder', { transaction })) as unknown as number
	if (!maxShowOrder) return 0
	return maxShowOrder
}
// returns the showOrder of the created attribute
export const createMemberAttribute = async ({
	required = false,
	isMemberDisplayed,
	isAdminDisplayed,
	label,
	type,
	section,
	choices,
	showOrder,
	transaction
}: {
	required: boolean
	isMemberDisplayed?: boolean
	isAdminDisplayed?: boolean
	label: string
	type: memberAttributeType
	section?: string | null
	choices?: CreationAttributes<AttributeChoice>[]
	showOrder?: number
	transaction: Transaction
}) => {
	if (showOrder === undefined) {
		showOrder = await getMaxShowOrder(transaction)
		showOrder++
	}

	const ma = await db.MemberAttribute.create(
		{
			required,
			label: label?.trim(),
			type: type,
			// eslint-disable-next-line security/detect-object-injection
			archType: memberAttributeArchTypeFromType[type],
			section,
			isMemberDisplayed,
			isAdminDisplayed,
			showOrder
		},
		{ transaction }
	)

	const queryInterface = db.sequelize.getQueryInterface()

	await queryInterface.addColumn(
		'members',
		`memberAttributeId${ma.memberAttributeId}`,
		{
			// eslint-disable-next-line security/detect-object-injection
			type: memberAttributeDbColType[type],
			defaultValue: null,
			allowNull: true
		},
		{ transaction }
	)
	if (choices && choices.length > 0) {
		await db.AttributeChoice.bulkCreate(
			choices.map((c, i) => ({
				contents: c.contents,
				showOrder: c.showOrder ?? i,
				memberAttributeId: ma.memberAttributeId
			})),
			{ fields: ['memberAttributeId', 'contents', 'showOrder'], transaction }
		)
	}
}

export const listMemberAttributes = db.MemberAttribute.listMemberAttributes
// db.memberAttributes.findAll({
// 	include: {
// 		association: db.memberAttributes.associations.attributeChoices,
// 		attributes: { exclude: ['memberAttributeId'] }
// 	},
// 	order: [
// 		['showOrder', 'asc'],
// 		[db.attributeChoices, col('showOrder'), 'asc']
// 	],
// 	transaction
// })

export const updateMemberAttributeOrder = async (
	params: { memberAttributeId: number; showOrder: number }[],
	transaction?: Transaction
) =>
	db.MemberAttribute.findAll({
		where: { memberAttributeId: { [Op.in]: params.map((p) => p.memberAttributeId) } },
		transaction
	}).then((memberAttributes) =>
		Promise.all(
			memberAttributes.map((c) => {
				const uc = params.find((p) => p.memberAttributeId == c.memberAttributeId)
				if (uc == undefined) throw new Error(`uc not found ${c.memberAttributeId}`)
				// if attribute is not in a section, update showOrder directly
				if (!c.section) return c.update({ showOrder: uc.showOrder }, { transaction })
				// else update showOrder of all attributes in the section
				return db.MemberAttribute.update(
					{ showOrder: uc.showOrder },
					{ where: { section: c.section }, transaction }
				)
			})
		)
	)

export const updateMemberAttribute = async ({
	memberAttributeId,
	required,
	isMemberDisplayed,
	isAdminDisplayed,
	label,
	choices,
	transaction
}: {
	memberAttributeId: number
	required: boolean
	isMemberDisplayed: boolean
	isAdminDisplayed: boolean
	label: string
	choices?: CreationAttributes<AttributeChoice>[]
	transaction?: Transaction
}) => {
	try {
		const memberAttribute = await db.MemberAttribute.findByPk(memberAttributeId, {
			include: { association: db.MemberAttribute.associations.attributeChoices },
			transaction
		})
		if (memberAttribute == null) {
			throw new AppError(SYSTEM_ERROR, `memberAttribute ${memberAttributeId} does not exist`)
		}
		memberAttribute.set({
			required,
			label: label?.trim(),
			isMemberDisplayed,
			isAdminDisplayed
		})
		if (memberAttribute.changed()) {
			await memberAttribute.save({ transaction })
		}
		if (memberAttribute.isAttributeTypeAddress() && memberAttribute.section) {
			await db.MemberAttribute.update(
				{
					isAdminDisplayed: memberAttribute.isAdminDisplayed,
					isMemberDisplayed: memberAttribute.isMemberDisplayed,
					label: memberAttribute.label,
					required: memberAttribute.generateAddressRequired(memberAttribute.required)
				},
				{
					where: {
						section: memberAttribute.section,
						memberAttributeId: {
							[Op.not]: memberAttribute.memberAttributeId
						}
					},
					transaction
				}
			)
		}

		const oldChoices = memberAttribute.attributeChoices ?? []

		// Check if we need to update the choices
		if (oldChoices.length > 0 && choices && choices.length > 0) {
			// Delete previous choices
			await db.AttributeChoice.destroy({ where: { memberAttributeId }, transaction })

			// Create new choices
			await db.AttributeChoice.bulkCreate(
				choices.map((c, i) => ({
					contents: c.contents,
					showOrder: c.showOrder ?? i,
					memberAttributeId
				})),
				{ fields: ['memberAttributeId', 'contents', 'showOrder'], transaction }
			)

			// Reset answers for all members the choices have changed
			if (!checkIfChoicesAreTheSame(oldChoices, choices))
				await updateMemberAttributeById({ [`memberAttributeId${memberAttributeId}`]: null }, {}, transaction)
		}
	} catch (error) {
		writeLog({ msg: 'Error trying to setMemberAttribute:', err: error }, 'error')
	}

	return
}

const updateMemberAttributeById = async (
	values: Record<string, any> = {},
	wheres: Record<string, any> = {},
	transaction?: Transaction
) =>
	db.sequelize.getQueryInterface().bulkUpdate(db.Member.tableName, values, wheres, {
		transaction
	})

export const deleteMemberAttribute = async (memberAttributeId: number, transaction?: Transaction) =>
	db.MemberAttribute.destroy({ where: { memberAttributeId }, transaction })

// Helper function to check if the choices are uniquely the same
// TODO: Handle the case where the choices are the same but the order is different and
// we want to update the order in the members answer to allow search sorting
const checkIfChoicesAreTheSame = (
	aChoices: CreationAttributes<AttributeChoice>[],
	bChoices: CreationAttributes<AttributeChoice>[]
): boolean => {
	if (aChoices.length !== bChoices.length) {
		return false
	}
	// Create unique map of existing choices set to 0
	const existingChoiceCounts = aChoices.reduce((choices, currChoice) => {
		const choiceKey = `choice${currChoice.attributeChoiceId}_${currChoice.contents}`
		choices[choiceKey] = 0
		return choices
	}, {} as Record<string, number>)

	// Check the new choices against the existing choices
	for (let i = 0; i < bChoices.length; i++) {
		const bChoiceKey = `choice${bChoices[i].attributeChoiceId}_${bChoices[i].contents}`
		if (bChoiceKey in existingChoiceCounts) {
			existingChoiceCounts[bChoiceKey] = existingChoiceCounts[bChoiceKey] + 1
		}
	}
	return Object.values(existingChoiceCounts).every((count) => count === 1)
}
